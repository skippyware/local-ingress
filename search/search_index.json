{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Local Ingress","text":"<p>Local Ingress is an opinionated stack aimed at making it easier to run multiple containerized projects and services locally.  Local Ingress is designed to be used with the <code>.test</code> TLD (a special purpose, reserved TLD) to avoid conflict with other TLDs.</p> <p>The key features are:</p> <ul> <li>Simple - Services are exposed on standard ports (80 - HTTP, and 443 - HTTPS) without conflict.</li> <li>Routing - Services define their own routes via Host, Headers, Path, Params, etc. using Traefik rules.</li> <li>DNS - Resolve DNS on both the host and within service containers.</li> <li>TLS - Services can choose to expose behind HTTPS listener with automatic certificate enrollment and renewal.  Wildcard certificates are fully supported.</li> <li>Decoupled - Services manage their own configurations via Docker Labels.</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>Developing multiple containerized projects locally requires ensuring that each service exposes itself on a different port.  With multiple services that must work together, this typically leads to configuring CORS and inter-project routing via <code>host.docker.internal</code> or adding extra hosts that resolve to <code>host-gateway</code>.  Additionally, if projects use 3rd party services that require HTTPS communications, there may be errors and warnings for mixed-content.</p> <p>The goal is to allow services that reside in different project repositories (and different Docker networks) to operate in a similar manner to staging environments.  Furthermore, the local host should have the same capability to access exposed services.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>Local Ingress provides an HTTP router (Traefik), TLS certificate management (StepCA), and DNS (CoreDNS).  The Traefik Docker provider monitors the Docker API to discover service containers and the request routing rules.  If the service container requires HTTPS, the service defition can enable certificate enrollment and optionally choose any domain(s) (including wildcard domains).  The local host is configured to use the DNS service for the <code>.test</code> TLD, which Docker automatically uses in the default resursive resolver.</p>"},{"location":"examples/","title":"Examples","text":"<p>The following is a collection of some exmaple use cases for services with Local Ingress.  To integrate with Local Ingress, a compose file needs to define the shared ingress network and define Traefik container lables to define the routing.</p>"},{"location":"examples/#define-the-ingress-network","title":"Define the Ingress Network","text":"<p>All projects and services that use Local Ingress must define the shared bridge network.  This is required so that Traefik can forward to the container when proxying tarffic/requests.</p> <p>Note</p> <p>The shared bridge network will be created if it doesn't exist.  The shared bridge network will fail to remove if any other container is still attached to the network.  This is expected behavior and should not be cause for concern.</p> docker-compose.yml<pre><code>networks:\n  ingress-net:\n    name: ingress-net\n</code></pre> <p>The network has a defined name so that Docker Compose does not assign an auto-generated name based on the project/directory.</p>"},{"location":"examples/#add-service-labels","title":"Add Service Labels","text":"<p>Traefik uses service labels to add services, define routes, and manage certificates (if requested).  The stack defines identifiers for the following:</p> <ul> <li>entrypoints - <code>web</code> (HTTP) and <code>websecure</code> (HTTPS)</li> <li>certresolver - <code>default</code> (supports HTTP-01 and DNS-01 challenegs)</li> <li>network - <code>ingress-net</code></li> </ul> <p>Note</p> <p>Each service should define a unique router and service name.  It is suggested to namespace them by project name for uniqueness.</p> <p>The following shows a simple example to expose a service at the URL <code>https://app.example.test</code>.</p> docker-compose.yml<pre><code>services:\n  app:\n    labels:\n      - \"traefik.enable=true\"  # expose this service via traefik\n      - \"traefik.http.routers.example-app.rule=Host(`app.example.test`)\"\n      - \"traefik.http.routers.example-app.entrypoints=websecure\"\n      - \"traefik.http.routers.example-app.tls=true\"\n      - \"traefik.http.routers.example-app.tls.certresolver=default\"\n      - \"traefik.http.routers.example-app.service=example-app\"\n      - \"traefik.http.services.example-app.loadbalancer.server.port=80\"  # the port the service listens on internally\n      - \"traefik.docker.network=ingress-net\"\n    networks:\n      - default  # include any other docker networks first\n      - ingress-net  # include ingress-net last\n</code></pre>"},{"location":"examples/basic-http/","title":"Basic HTTP","text":"<p>Expose a single web application on a fixed domain via HTTP (no encryption).</p> <p>This example could be a static web application or monolithic application.</p> <p>URL - http://basic.test</p>"},{"location":"examples/basic-http/#service","title":"Service","text":"<pre><code>services:\n  www:\n    image: nginx:1.27-alpine\n    networks:\n      - default\n      - ingress-net\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.basic-app.rule=Host(`basic.test`)\"\n      - \"traefik.http.routers.basic-app.entrypoints=web\"\n      - \"traefik.http.routers.basic-app.service=basic-app\"\n      - \"traefik.http.services.basic-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n\nnetworks:\n  ingress-net:\n    name: ingress-net\n</code></pre>"},{"location":"examples/basic-https/","title":"Basic HTTPS","text":"<p>Expose a single web application on a fixed domain via HTTPS (TLS encryption).</p> <p>This example could be a static web application or monolithic application.</p> <p>URL - https://basic.test</p>"},{"location":"examples/basic-https/#service","title":"Service","text":"<pre><code>services:\n  www:\n    image: nginx:1.27-alpine\n    networks:\n      - default\n      - ingress-net\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.basic-app.rule=Host(`basic.test`)\"\n      - \"traefik.http.routers.basic-app.entrypoints=websecure\"\n      - \"traefik.http.routers.basic-app.tls=true\"\n      - \"traefik.http.routers.basic-app.tls.certresolver=default\"\n      - \"traefik.http.routers.basic-app.service=basic-app\"\n      - \"traefik.http.services.basic-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n\nnetworks:\n  ingress-net:\n    name: ingress-net\n</code></pre>"},{"location":"examples/multi-service/","title":"Multi Service","text":"<p>Expose two web applications on the same domain using path routing.</p> <p>This example may represent a web application with the frontend and backend split into different projects.  This example will route requests to <code>/api/*</code> to the backend service, while all other requests go to the frontend service.</p> <p>URL - https://basic.test</p>"},{"location":"examples/multi-service/#frontend-service","title":"Frontend Service","text":"<pre><code>services:\n  www:\n    image: nginx:1.27-alpine\n    networks:\n      - default\n      - ingress-net\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.frontend-basic-app.rule=Host(`basic.test`)\"\n      - \"traefik.http.routers.frontend-basic-app.entrypoints=websecure\"\n      - \"traefik.http.routers.frontend-basic-app.tls=true\"\n      - \"traefik.http.routers.frontend-basic-app.tls.certresolver=default\"\n      - \"traefik.http.routers.frontend-basic-app.service=frontend-basic-app\"\n      - \"traefik.http.services.frontend-basic-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n\nnetworks:\n  ingress-net:\n    name: ingress-net\n</code></pre>"},{"location":"examples/multi-service/#backend-service","title":"Backend Service","text":"<pre><code>services:\n  www:\n    image: nginx:1.27-alpine\n    networks:\n      - default\n      - ingress-net\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.backend-basic-app.rule=Host(`basic.test`) &amp;&amp; PathPrefix(`/api`)\"\n      - \"traefik.http.routers.backend-basic-app.entrypoints=websecure\"\n      - \"traefik.http.routers.backend-basic-app.tls=true\"\n      - \"traefik.http.routers.backend-basic-app.tls.certresolver=default\"\n      - \"traefik.http.routers.backend-basic-app.service=backend-basic-app\"\n      - \"traefik.http.services.backend-basic-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n\nnetworks:\n  ingress-net:\n    name: ingress-net\n</code></pre>"},{"location":"examples/subdomain-routing/","title":"Subdomain Routing","text":"<p>Expose an application that uses subdomains for routing or multi-tenancy.</p> <p>This example may represent a web application that uses subdomains for a multi-tenant system.  For cases where the subdomain is not known, wildcard certificates are required.</p> <p>URL - https://basic.test or https://subdomain.basic.test</p>"},{"location":"examples/subdomain-routing/#service","title":"Service","text":"<pre><code>services:\n  www:\n    image: nginx:1.27-alpine\n    networks:\n      - default\n      - ingress-net\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.basic-app.rule=HostRegexp(`basic.test`,`{subdomain:[a-z]+}.basic.test`)\"\n      - \"traefik.http.routers.basic-app.entrypoints=websecure\"\n      - \"traefik.http.routers.basic-app.tls=true\"\n      - \"traefik.http.routers.basic-app.tls.certresolver=default\"\n      - \"traefik.http.routers.basic-app.tls.domains[0].main=basic.test\"\n      - \"traefik.http.routers.basic-app.tls.domains[0].sans=*.basic.test\"\n      - \"traefik.http.routers.basic-app.service=basic-app\"\n      - \"traefik.http.services.basic-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n\nnetworks:\n  ingress-net:\n    name: ingress-net\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<ol> <li>Clone the Local Ingress repository.</li> </ol> <pre><code>git clone https://github.com/skippyware/local-ingress &amp;&amp; cd local-ingress\n</code></pre> <ol> <li>Follow the installation instructions for your system.</li> <li>Start the stack.</li> </ol> <pre><code>docker compose up -d\n</code></pre> <ol> <li>Add <code>ingress-net</code> network to projects/services compose file.</li> </ol> <pre><code>networks:\n  ingress-net:\n    name: ingress-net\n</code></pre> <ol> <li>Add container labels and attach containers to projects/services compose file.</li> </ol> <pre><code>services:\n  app:\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.example-app.rule=Host(`app.example.test`)\"\n      - \"traefik.http.routers.example-app.entrypoints=websecure\"\n      - \"traefik.http.routers.example-app.tls=true\"\n      - \"traefik.http.routers.example-app.tls.certresolver=default\"\n      - \"traefik.http.routers.example-app.service=example-app\"\n      - \"traefik.http.services.example-app.loadbalancer.server.port=80\"\n      - \"traefik.docker.network=ingress-net\"\n    networks:\n      - default  # include any other docker networks first\n      - ingress-net  # include ingress-net last\n</code></pre> <ol> <li> <p>Start projects/services.</p> </li> <li> <p>Access your project/service via the ingress: https://app.example.test</p> </li> </ol>"},{"location":"getting-started/install/","title":"Installation","text":"<p>Local Ingress requires two configuration changes to the host system:</p> <ul> <li>DNS Zone Reoslver - This allows the host to send DNS queries for our zone to the stack.</li> <li>Loopback Alias to Docker Desktop Subnet Gateway (MacOS and Windows only) - Docker Desktop runs in a Virtual Machine on MacOS and Windows.  This allows the MacOS/Windows host to understand that Docker's magic <code>host-gateway</code> IP address is for the loopback interface.</li> </ul>"},{"location":"getting-started/install/#set-dns-resolver-port-windows-only","title":"Set DNS Resolver Port (Windows Only)","text":"<p>Windows DNS client rules don't support specifying a port for the nameserver.  As a result, the stack must be configured to expose DNS resolver on the standard port 53.  The compose file supports customization via environment variables.</p> <pre><code>echo \"LOCAL_INGRESS_DNS_PORT=53\" &gt; .env\n</code></pre>"},{"location":"getting-started/install/#generate-system-configuration","title":"Generate System Configuration","text":"<p>Note</p> <p>Any configuration changes to the Docker Desktop subnet will require an update to the host system configuration to get the correct alias for the loopback interface.  It isn't common for the Docker Desktop subnet to change unless you have a collision with a local network.</p> <p>This will run a container to get the Docker <code>host-gateway</code> IP address and template out system configuration files.</p> <p>Manual</p> <pre><code>docker compose run --rm --entrypoint='' --no-deps \\\n    -v \"${PWD}/system-config:/system-config\" \\\n    -v \"${PWD}/dns-zone/system-config.sh:/system-config.sh\" \\\n    -w /system-config dns-zone /system-config.sh\n</code></pre> <p>Automated</p> <pre><code>make system-config-generate\n</code></pre> <p>Generated files:</p> File Description <code>system-config/docker.gateway</code> Docker Desktop subnet gateway IP address <code>system-config/darwin/org.user.lo0-docker-gateway-alias.plist</code> MacOS launch definition to alias the loopback interface on restart"},{"location":"getting-started/install/#add-dns-resolver","title":"Add DNS Resolver","text":"MacOSLinuxWindows <p>Add a DNS rule to use the stack resolver for all <code>.test</code> domains.</p> <p>Manual</p> <p>With root priviledges, open <code>/etc/resolver/test</code> and add the following:</p> <pre><code>nameserver 127.0.0.1\nport 1053\n</code></pre> <p>-OR-</p> <p>Automated</p> <pre><code>cat &lt;&lt;EOF |\nnameserver 127.0.0.1\nport 1053\nEOF\nsudo tee /etc/resolver/test &gt;/dev/null\n</code></pre> <p>Add a DNS rule to use the stack resolver for all <code>.test</code> domains.</p> <p>systemd-resolved</p> <p>With root priviledges, open <code>/etc/systemd/resolved.conf</code> and add the following:</p> <pre><code>[Resolve]\nDNS=127.0.0.1:1053\nDomains=~test\n</code></pre> <p>Add a DNS rule to use the stack resolver for all <code>.test</code> domains.  This will require Administrator priviledges.</p> <pre><code>Add-DnsClientNrptRule -Namespace \".test\" -NameServers \"127.0.0.1\" -Comment \"Local Ingress DNS Resolver\"\n</code></pre>"},{"location":"getting-started/install/#alias-loopback-interface","title":"Alias Loopback Interface","text":"MacOSLinuxWindows <p>MacOS will clear the loopback IP alias on restart.  The following steps will add a launch daemon definition to alias the Docker Desktop gateway IP address on boot.</p> <p>Manual</p> <p>Install the launch daemon definition.</p> <pre><code>sudo install -g wheel -o root -m 0644 \\\n    ./system-config/darwin/org.user.lo0-docker-gateway-alias.plist \\\n    /Library/LaunchDaemons/org.user.lo0-docker-gateway-alias.plist\n</code></pre> <p>Load the launch daemon.</p> <pre><code>sudo launchctl load \\\n    /Library/LaunchDaemons/org.user.lo0-docker-gateway-alias.plist\n</code></pre> <p>-OR-</p> <p>Automated</p> <pre><code>make system-config\n</code></pre> <p>Not required!  Docker doesn't run inside a Virtual Machine on Linux.  The Docker bridge network is directly reachable.</p> <p>Print the Docker Desktop gateway IP address.</p> <pre><code>type system-config\\docker.gateway\n</code></pre> <p>Add an alias for the Docker Desktop gateway IP address to the Loopback interface.  This will require Administrator priviledges.</p> <pre><code>netsh interface ip add address \"Loopback\" DOCKER_GW_ADDRESS 255.255.255.255\n</code></pre>"},{"location":"getting-started/root-ca/","title":"Root CA","text":"<p>In some cases it may be required to configure other services to trust the Local Ingress Root CA.  The Root CA may be exported from the stack by running one of the following commands:</p> <pre><code>make ca-extract\n</code></pre> <p>-OR-</p> <pre><code>docker compose cp \\\n    --follow-link stepca:/home/step/certs/root_ca.crt \\\n    ./system-config/ca.crt\n</code></pre>"},{"location":"getting-started/stack/","title":"Managing Stack","text":"<p>Local Ingress is a simple set of containers managed by Docker Compose.</p>"},{"location":"getting-started/stack/#start","title":"Start","text":"<p>Start the services, creating a PKI on first run.</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"getting-started/stack/#stop","title":"Stop","text":"<p>Stop the services, keeping your PKI.</p> <pre><code>docker compose down\n</code></pre>"},{"location":"getting-started/stack/#rebuildrecreate","title":"Rebuild/Recreate","text":"<p>Rebuilding is a matter of destroying the volumes and starting the stack.</p> <pre><code>docker compose down -v\n</code></pre>"},{"location":"getting-started/uninstall/","title":"Uninstall","text":"<p>Coming soon</p>"},{"location":"stack/","title":"Stack","text":"<p>Local Ingress is primarily built upon the great work of other open source initiatives.  The stack consists of 5 services that make this possible.</p> <ul> <li>Traefik - Ingress service.</li> <li>Step CA - Certificate manager and ACME provider.</li> <li>ACME DNS - ACME DNS challenge service.</li> <li>CoreDNS - Primary DNS forwarder.</li> <li>DNS Zone - Simple ACME DNS HTTP storage service and DNS Zone template engine.</li> </ul>"},{"location":"stack/#ingress","title":"Ingress","text":"<p>Traefik proxy provides all ingress functionality.  Services are automatically discovered and the configuration loaded via the Docker provider.  The Traefik Docker provider uses container labels to retrieve routing configuration, service port, TLS configuration (optional), etc.</p> <p>Local Ingress disables containers by default from being attached to the Traefik proxy.  As it is common for projects/services to include a number of internal support services (e.g. database, cache, queues, etc.), many containers for a project should not be exposed.  Only those containers that should be exposed via Traefik will be explicity marked via container labels.</p> <p>Local Ingress exposes the following ports:</p> <ul> <li>80 (HTTP) - Unencrypted HTTP traffic.  Also used for ACME HTTP-01 challeneges by Traefik and Step CA.</li> <li>443 (HTTPS) - TLS encrypted HTTP traffic.</li> <li>8080 (HTTP Alt) - Traefik proxy dashboard.</li> </ul> <p>Provided By: Traefik</p>"},{"location":"stack/#pki","title":"PKI","text":"<p>A simple PKI, consisting of Root and Intermediate CAs, is created on your system.  For security, no PKI artifacts or key material exists staically or is provided by Local Ingress.  At any time this PKI can be re-created by stopping the stack and destroying the container volumes.  The stack will reinitialize and create a new PKI.</p> <p>Provided By: Step CA</p>"},{"location":"stack/#dns","title":"DNS","text":"<p>DNS is what makes Local Ingress possible across various project/service repositories.  DNS must be resolvable from the host system as well as within each container.  The host configuration makes it possible for the default Docker DNS resolver to expose the zone without any additional DNS overrides in each project/service.</p> <p>The stack DNS resolver is configured on the host as a resolver for the zone (default <code>.test</code>).</p> <p>Provided By: CoreDNS, ACME DNS, and DNS Zone</p>"},{"location":"stack/customize/","title":"Customize","text":"<p>Local Ingress supports some basic customization via environment variables.  Docker Compose supports a number of ways to specify envirnment variables.  If you plan on making a permanent change, the suggested method is to define any overrides in <code>.env</code>.</p> <p>Warning</p> <p>Do not set the <code>LOCAL_INGRESS_ACME_DNS_ZONE</code> and <code>LOCAL_INGRESS_DNS_ZONE</code> to the same value.  As <code>LOCAL_INGRESS_DNS_ZONE</code> is the SOA for the zone, it will not allow for ACME DNS challenges to correctly verify.</p> <p>Info</p> <p>For MacOS, it is not recommened to set the <code>LOCAL_INGRESS_DNS_ZONE</code> to <code>local</code>.  Setting to <code>local</code> may conflict with the MacOS default discovery service.</p> Setting Default Description <code>LOCAL_INGRESS_ACME_DNS_ZONE</code> <code>local</code> The ACME DNS challenge zone. <code>LOCAL_INGRESS_DNS_ZONE</code> <code>test</code> The DNS zone for all services. <code>LOCAL_INGRESS_DNS_PORT</code> <code>1053</code> The exposed port for the DNS resolver. <code>LOCAL_INGRESS_STEPCA_DEBUG</code> <code>0</code> Enable StepCA debug output. Enabled <code>1</code>, Disabled <code>0</code>. <code>LOCAL_INGRESS_DNS_PORT</code> <code>1053</code> The exposed port for the DNS resolver. <code>LOCAL_INGRESS_TRAEFIK_LOG_LEVEL</code> <code>WARN</code> The Traefik log level. <code>LOCAL_INGRESS_TRAEFIK_RULE_SYNTAX</code> <code>v3</code> The traefik default rules syntax."}]}